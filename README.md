# CS-465-Full-Stack-Development-I
## Architecture
#### Compare and contrast the types of frontend development you used in your full stack project, including Express HTML, JavaScript, and the single-page application (SPA).
I will first contrast each of the different types of frontend development utilized by describing their purpose within the application. Beginning with Express, Express was used to set up a web server to listen to incoming requests and return relevant responses. In addition, it defined a directory structure where one folder was set up to serve static files in a nonblocking way. Angular was used to handle the application's logic in a structured way. The Model-View-Controller architecture that was used solved the problem of developing the SPA by extending its functionality of HTML with directives. With its feature of Two-Way Data Binding, the Model and the View were synchronized so that when data in the Model changed, the View automatically reflected that change and vice versa. Also, Angular was used to develop the SPA to allow different views to be shown on the page, along with a variety of data sets, but with the page itself never fully reloading. This approach was used to reduce the number of resources needed on the server, because you would be essentially crowdsourcing the computational power. Each user's browser would do the hard work and the server would only have to serve up static files and data on request. JavaScript was the programming language used throughout the project where methods pertaining to and defining the application's logic and behavior were defined. The SPA architecture was used to load a static page with JS where the backend code was not used for the initial request; essentially, it was merely meant to load very simple HTML and fetch JS. Once the HTML and JS arrived at the browser, the JS was executed and started making requests to the server for data. This is what the backend code provided in the form of JSON responses. The Document Object Model (DOM) was built dynamically based on that data, starting with a blank page. The DOM elements which are dynamically assembled by JS are then shown to the user. In comparison, each resource used for frontend development used JavaScript to pass data and perform its intended tasks. Data was rendered on the web page thanks to HTML and CSS, which were defined with the files of the MVC folder structure.

#### Why did the backend use a NoSQL MongoDB database?
I believe that the backend utilized the NoSQL MongoDB database because of its document-style approach to storing data. While SQL databases use columns to define the name and data type, and rows to represent a different entry, MongoDB does not use this schema. Instead of a column defining what should be in the row, each row is a document, and this document both defines and holds the data itself. This less-structured approach means that a collection of documents could have a wide variety of data inside. This allows you to create indexes on more than just the unique identifier field, and query indexed fields much faster. You can also create some complex queries against a MongoDB database. The biggest advantage of using MongoDB is its data modeling feature which defines what data can be in a document and what data must be in a document. When storing user information, you may want to be able to save the first name, last name, email address, and phone number. But you need only the first name and email address, and the email address must be unique. This information is defined in a schema, which is used as the basis for the data model.

## Functionality
#### How is JSON different from JavaScript and how does JSON tie together the frontend and backend development pieces?
JSON is a JavaScript way of holding data; it is used to exchange information between web clients and web servers. JavaScript is a programming language that can calculate, manipulate and validate data, as well as update and change HTML and CSS. JSON was used in this application for its lightweight format for storing and transporting data to tie together the front- and backend development pieces. Rather than a MongoDB document holding a data set that corresponds to a set of columns, a document holds name/value pairs, which makes a document useful because it both describes and defines the data. This was seen when each trip in the application was stored as JSON and rendered on the web page. The process begins when HTTP requests arrive from the browser (frontend) at the backend. Those requests may contain data in the HTTP headers or request body. The intent may be to request new data or to transmit user-created data to the backend. HTTP requests are constructed inside the user's browser and sent off. There is a response for each request, carrying information in the HTTP headers and the request body. Those responses at the backend arrive back at the user's browser and contain HTML-formatted responses, other static files (CSS, JS, images, etc.), JSON-formatted data, and/or no body at all; just a status code and header fields. The frontend sends simple HTTP requests without a body, form data (in this case trip information), and JSON-formatted data.

#### Provide instances in the full stack process when you refactored code to improve functionality and efficiencies and name the benefits that come from reusable user interface (UI) components.
One instance where I refactored the code to improve functionality and efficiencies was when I had to radically change the architecture by replacing the Express application and move all the logic into an SPA, using Angular. This allowed me to focus on Angular as I already knew what the application was supposed do and had a data API that was ready for use. Another instance of refactoring the code was for the usage of the Handlebars templating engine to create the HTML template, including placeholders for data, and then passing it some data. The engine compiled the template and data together to create the final HTML markup that the browser would receive. The major benefit that came from reusable UI components was that I did not have to redesign these components to enhance the features of the application. Minor tweaking could be used to add rich functionality to the application without losing its intended behavior. Another benefit came from simplifying the code using the templating engine, where long lines of code were instead replaced by placeholders for data that was passed before compilation.

## Testing
#### Methods for request and retrieval necessitate various types of API testing of endpoints, in addition to the difficulties of testing with added layers of security. Explain your understanding of methods, endpoints, and security in a full stack application.
In the final step of building the application, I added functionality to enable users to register and log in. I learned how to make use of a users' data while they are using the application by using encrypted tokens. I built upon everything I had done so far by adding authentication to the Angular SPA. This involved saving the users' information in the database and securing certain API endpoints so that they can be used only by authenticated users. Testing of the API endpoints was necessary to ensure that the application worked as intended. GET, PUT and POST requests had to be made to display data on the webpage, and to edit and add data to the application. As an authenticated user, it was easy to test the security of the application by using the browser's developer tools function and the Express framework. With lines of code to the console and error handling methods that displayed the call to certain functions within the code, I was able to debug which method worked, when it was working, and what error had occurred to inform myself of what the application was doing.

## Reflection
#### How has this course helped you in reaching your professional goals? What skills have you learned, developed, or mastered in this course to help you become a more marketable candidate in your career field?
This course has helped me in reaching my professional goal of becoming a software engineer by allowing me to work with and slowly understand the different applications that work together within the process of software development. I had built webpages before, but I did not use a stack of technologies to do it. This experience has shown me how complicated the process of building an entire fully-functional application really is. It also added to my experience in debugging as several times while building my application I ran into errors that I had to find and fix before my application would run properly. Some of the solutions I implemented came from my peers, which also showed me how invaluable having a supportive team really is.
